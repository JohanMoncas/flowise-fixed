"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MCPToolkit = void 0;
exports.MCPTool = MCPTool;
const types_js_1 = require("@modelcontextprotocol/sdk/types.js");
const index_js_1 = require("@modelcontextprotocol/sdk/client/index.js");
const stdio_js_1 = require("@modelcontextprotocol/sdk/client/stdio.js");
const tools_1 = require("@langchain/core/tools");
const zod_1 = require("zod");
class MCPToolkit extends tools_1.BaseToolkit {
    constructor(serverParams, transport) {
        super();
        this.tools = [];
        this._tools = null;
        this.transport = null;
        this.client = null;
        if (transport === 'stdio') {
            this.transport = new stdio_js_1.StdioClientTransport(serverParams);
        }
        else {
            // TODO: this.transport = new SSEClientTransport(serverParams.url);
        }
    }
    async initialize() {
        if (this._tools === null) {
            this.client = new index_js_1.Client({
                name: 'flowise-client',
                version: '1.0.0'
            }, {
                capabilities: {}
            });
            if (this.transport === null) {
                throw new Error('Transport is not initialized');
            }
            await this.client.connect(this.transport);
            this._tools = await this.client.request({ method: 'tools/list' }, types_js_1.ListToolsResultSchema);
            this.tools = await this.get_tools();
        }
    }
    async get_tools() {
        if (this._tools === null || this.client === null) {
            throw new Error('Must initialize the toolkit first');
        }
        const toolsPromises = this._tools.tools.map(async (tool) => {
            if (this.client === null) {
                throw new Error('Client is not initialized');
            }
            return await MCPTool({
                client: this.client,
                name: tool.name,
                description: tool.description || '',
                argsSchema: createSchemaModel(tool.inputSchema)
            });
        });
        return Promise.all(toolsPromises);
    }
}
exports.MCPToolkit = MCPToolkit;
async function MCPTool({ client, name, description, argsSchema }) {
    return (0, tools_1.tool)(async (input) => {
        const req = { method: 'tools/call', params: { name: name, arguments: input } };
        const res = await client.request(req, types_js_1.CallToolResultSchema);
        const content = res.content;
        const contentString = JSON.stringify(content);
        return contentString;
    }, {
        name: name,
        description: description,
        schema: argsSchema
    });
}
function createSchemaModel(inputSchema) {
    if (inputSchema.type !== 'object' || !inputSchema.properties) {
        throw new Error('Invalid schema type or missing properties');
    }
    const schemaProperties = Object.entries(inputSchema.properties).reduce((acc, [key, _]) => {
        acc[key] = zod_1.z.any();
        return acc;
    }, {});
    return zod_1.z.object(schemaProperties);
}
//# sourceMappingURL=core.js.map