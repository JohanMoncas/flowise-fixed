"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("../core");
const mcpServerConfig = `{
    "command": "npx",
    "args": ["-y", "@modelcontextprotocol/server-filesystem", "/path/to/allowed/files"]
}`;
class Custom_MCP {
    constructor() {
        //@ts-ignore
        this.loadMethods = {
            listActions: async (nodeData) => {
                try {
                    const toolset = await this.getTools(nodeData);
                    toolset.sort((a, b) => a.name.localeCompare(b.name));
                    return toolset.map(({ name, ...rest }) => ({
                        label: name.toUpperCase(),
                        name: name,
                        description: rest.description || name
                    }));
                }
                catch (error) {
                    return [
                        {
                            label: 'No Available Actions',
                            name: 'error',
                            description: 'No available actions, please check your API key and refresh'
                        }
                    ];
                }
            }
        };
        this.label = 'Custom MCP';
        this.name = 'customMCP';
        this.version = 1.0;
        this.type = 'Custom MCP Tool';
        this.icon = 'customMCP.png';
        this.category = 'Tools (MCP)';
        this.description = 'Custom MCP Config';
        this.documentation = 'https://github.com/modelcontextprotocol/servers/tree/main/src/brave-search';
        this.inputs = [
            {
                label: 'MCP Server Config',
                name: 'mcpServerConfig',
                type: 'code',
                hideCodeExecute: true,
                placeholder: mcpServerConfig
            },
            {
                label: 'Available Actions',
                name: 'mcpActions',
                type: 'asyncMultiOptions',
                loadMethod: 'listActions',
                refresh: true
            }
        ];
        this.baseClasses = ['Tool'];
    }
    async init(nodeData) {
        const tools = await this.getTools(nodeData);
        const _mcpActions = nodeData.inputs?.mcpActions;
        let mcpActions = [];
        if (_mcpActions) {
            try {
                mcpActions = typeof _mcpActions === 'string' ? JSON.parse(_mcpActions) : _mcpActions;
            }
            catch (error) {
                console.error('Error parsing mcp actions:', error);
            }
        }
        return tools.filter((tool) => mcpActions.includes(tool.name));
    }
    async getTools(nodeData) {
        const mcpServerConfig = nodeData.inputs?.mcpServerConfig;
        if (!mcpServerConfig) {
            throw new Error('MCP Server Config is required');
        }
        try {
            let serverParams;
            if (typeof mcpServerConfig === 'object') {
                serverParams = mcpServerConfig;
            }
            else if (typeof mcpServerConfig === 'string') {
                const serverParamsString = convertToValidJSONString(mcpServerConfig);
                serverParams = JSON.parse(serverParamsString);
            }
            const toolkit = new core_1.MCPToolkit(serverParams, 'stdio');
            await toolkit.initialize();
            const tools = toolkit.tools ?? [];
            return tools;
        }
        catch (error) {
            throw new Error(`Invalid MCP Server Config: ${error}`);
        }
    }
}
function convertToValidJSONString(inputString) {
    try {
        const jsObject = Function('return ' + inputString)();
        return JSON.stringify(jsObject, null, 2);
    }
    catch (error) {
        console.error('Error converting to JSON:', error);
        return '';
    }
}
module.exports = { nodeClass: Custom_MCP };
//# sourceMappingURL=CustomMCP.js.map